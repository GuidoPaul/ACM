/*************************************************************************
	> File Name: 436B.c
	> Author: Bslin
	> Mail: Baoshenglin1994@gmail.com
	> Created Time: 2014年06月16日 星期一 10时33分54秒
	> 题意：1）小怪兽从顶行的某个格子垂直往下走，如果在格子中（在半路上或非格子內不算）
		遇到小蜘蛛就要加上遇到的蜘蛛数，加到这一列的数据（遇到蜘蛛的个数）中。
		2）由于蜘蛛可以多只同时出现在一个格子中，因此当小怪兽在某个格子遇到蜘蛛时，
		可能同时遇到多只蜘蛛，遇到几只就在这列数据（遇到蜘蛛的个数）中加上几只。
		3）小蜘蛛在方格中只按一个方向爬行，因此可能会爬出方格。
		4）保证一开始顶行没有蜘蛛，小怪兽和小蜘蛛的爬行速度相同，即每次爬一个格子
		（相邻的格子），输出每列的遇到蜘蛛的个数。
	> 思路：可以对小蜘蛛的爬行方向做讨论。
		1）若小蜘蛛一直往下爬，那么小怪兽一定遇不到它（爬行速度相同）。
		2）若小蜘蛛往左或往右爬，那么只要考虑小怪兽爬到和小蜘蛛同行时小蜘蛛的位置，
		在格子內的话，就将该列遇到的蜘蛛数+1。
		3）若小蜘蛛往上爬就要考虑和小怪兽是在格子內相遇还是半路上（非格子內）相遇，
		只需要计算小蜘蛛当前行数距顶行的奇偶性就可以。
	> 注意：下标不要越界，即处理小蜘蛛位置的时候，当小怪兽到小蜘蛛同行时，若小蜘蛛已经
		爬出方格就不要处理了。
 ************************************************************************/

#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]) {
	freopen("in.txt", "r", stdin);
	int n, m, k, i, j;
	int ans[2010];
	char ch;
	while(scanf("%d%d%d", &n, &m, &k) != EOF) {
		memset(ans, 0, sizeof(ans));
		getchar();
		for (i = 0; i < n; i++) {
			for (j = 0; j < m; j++) {
				scanf("%c", &ch);
				if(ch == 'U') {
					if(i % 2 == 0) {
						ans[j] ++;
					}
				} else if(ch == 'R' && j + i < m) { // 注意下标越界
					ans[j + i] ++;
				} else if(ch == 'L' && j - i >= 0) { // 注意下标越界
					ans[j - i] ++;
				}
			}
			getchar();
		}
		for (j = 0; j < m; j++) {
			if(j == 0) printf("%d", ans[j]);
			else printf(" %d", ans[j]);
		}
		printf("\n");
	}
	return 0;
}
